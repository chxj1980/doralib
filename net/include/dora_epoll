#ifndef _DORA_EPOLL_H_
#define _DORA_EPOLL_H_

#include <cstring>
#include <memory>
#include <vector>

#include <unistd.h>
#include <sys/epoll.h>

#include "dora_exception.h"
#include "dora_socket.h"
#include "dora_dgram.h"

using std::vector;

namespace doralib {

template <typename T>
class epollset {
   public:
    typedef std::pair<std::vector<T*>, std::vector<T*>> ready_socks;

    std::vector<dgram_socket *> dgram;
    

    epollset(unsigned int maxevents = 128);
    epollset(const epollset&) = delete;
    epollset(epollset&&);
    ~epollset(void);

    void add_fd(T& sock, int method);
    void del_fd(const T& sock);
    ready_socks wait(int timeout = -1);

   private:
    /// maxevents is passed to `epoll_wait`.
    unsigned int maxevents;
    /// The file descriptor used by the epoll API
    int epollfd;
    /// Array of structures, filled on the return of `epoll_wait`.
    struct epoll_event* events;
};

/**
 * @}
 */

/**
 * @brief Construct a new epollset
 *
 * @param maxevs Maximum event number returned by `epoll_wait`. Default is 128.
 */
template <typename T>
epollset<T>::epollset(unsigned int maxevs)
    : maxevents(maxevs), events(new struct epoll_event[maxevs]) {
    epollfd = epoll_create1(0);

    if (epollfd < 0)
        throw socket_exception(
            __FILE__, __LINE__,
            string("epoll_create1 failed: ") + strerror(errno));
}

/**
 * @brief Move constructor for epollsets.
 */
template <typename T>
epollset<T>::epollset(epollset&& new_epollset) {
    maxevents = new_epollset.maxevents;
    epollfd = new_epollset.epollfd;
    events = new_epollset.events;

    new_epollset.epollfd = -1;
    new_epollset.events = nullptr;
}

template <typename T>
epollset<T>::~epollset(void) {
    close(epollfd);
    delete[] events;
}

/**
 * @brief Add a socket to an `epollset`.
 *
 * @param sock The socket to be added.
 * @param method Any combination of `LIBSOCKET_READ` and `LIBSOCKET_WRITE`.
 */
template <typename T>
void epollset<T>::add_fd(T& sock, int method) {
    struct epoll_event new_event;

    new_event.data.ptr = 0;  // ptr is the largest field (8 bytes on 64bit)
    new_event.events = 0;

    if (method & LIBSOCKET_READ) new_event.events |= EPOLLIN;
    if (method & LIBSOCKET_WRITE) new_event.events |= EPOLLOUT;

    new_event.data.ptr = &sock;

    if (0 > epoll_ctl(epollfd, EPOLL_CTL_ADD, sock.getfd(), &new_event))
        throw socket_exception(__FILE__, __LINE__,
                               string("epoll_ctl failed: ") + strerror(errno));
}

/**
 * @brief Remove a file descriptor from an epoll set.
 *
 * @param sock The socket to remove.
 */
template <typename T>
void epollset<T>::del_fd(const T& sock) {
    if (0 > epoll_ctl(epollfd, EPOLL_CTL_DEL, sock.getfd(), nullptr))
        throw socket_exception(__FILE__, __LINE__,
                               string("epoll_ctl failed: ") + strerror(errno));
}

/**
 * @brief Wait for an event on any file descriptor.
 *
 * @param timeout (default: -1) Timeout, in milliseconds, after which to return
 * if no event has occurred yet. -1 for indefinite waiting, 0 for non-blocking
 * access.
 *
 * @return A pair of vectors containing pointers to SocketTs:
 * (ready_for_reading[],ready_for_writing[]). With `r` being the returned pair,
 * access the sockets using statements like `r.first.size() > 0 ? r.first[0] :
 * nullptr` or the like.
 *
 * *Hint*: If you need to know what socket has been returned, maintain a mapping
 * from socket pointers to some identification code. Using that mapping, you
 * will be able to identify the sockets.
 *
 * *Hint 2*: It never does any harm to check the length of the returned
 * `vector`s; with the included example `http_epoll.cpp`, spurious
 * empty-returning epoll calls could be observed. However, it is not clear if
 * this is a bug in the doralib implementation or usual behavior of epoll.
 */
template <typename T>
typename epollset<T>::ready_socks epollset<T>::wait(int timeout) {
    int nfds;
    ready_socks ready;

    if (0 > (nfds = epoll_wait(epollfd, events, maxevents, timeout)))
        throw socket_exception(__FILE__, __LINE__,
                               string("epoll_wait failed: ") + strerror(errno));

    for (int i = 0; i < nfds; i++) {
        if (events[i].events == EPOLLIN)
            ready.first.push_back(static_cast<T*>(events[i].data.ptr));
        if (events[i].events == EPOLLOUT)
            ready.second.push_back(static_cast<T*>(events[i].data.ptr));
    }

    return ready;
}

}  // namespace doralib
#endif
